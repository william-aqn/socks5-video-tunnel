# Video-Go Traffic Tunneller

Экспериментальный проект для туннелирования SOCKS5 трафика через видеопоток (виртуальная камера + захват экрана).

## Принцип работы

Данные кодируются в цветные блоки пикселей в RGBA-кадрах. Система работает в двунаправленном режиме:
1.  **Исходящий поток**: Данные упаковываются в кадры с использованием **8-цветной палитры** (3 бита на блок) и отправляются в виртуальную веб-камеру.
2.  **Входящий поток**: Система захватывает область экрана, находит маркеры, применяет **билинейную интерполяцию** для компенсации геометрических искажений и декодирует данные.

### Надежность и целостность (ARQ)
Для работы в условиях нестабильного видеопотока (пропуски кадров, артефакты сжатия) внедрен протокол **ARQ (Automatic Repeat Request)**:
*   **Подтверждение доставки (ACK)**: Каждый пакет данных содержит номер последовательности (`Seq`) и номер последнего успешно полученного пакета (`Ack`).
*   **Ретрансляция**: Если отправитель не получает подтверждение в течение 1 секунды, пакет отправляется повторно.
*   **Контроль целостности**: Используется **CRC32 (IEEE)**. Это гарантирует отсутствие поврежденных байтов в TCP-потоке, что критично для работы HTTPS/TLS (устраняет ошибки `BAD_MAC_ALERT`).
*   **Упорядочивание**: Приемник буферизует пакеты, пришедшие не по порядку, и собирает их в правильной последовательности перед записью в сокет.

### Синхронизация и калибровка
При запуске клиент и сервер проходят обязательную фазу калибровки для определения максимально возможного FPS в текущем видеоканале:
1.  **Инициация**: Сервер молчит. Клиент начинает отправку пакетов синхронизации на максимальной скорости.
2.  **Калибровка сервера (10 сек)**: Заметив пакеты клиента, сервер в течение 10 секунд измеряет входящий framerate.
3.  **Калибровка клиента (10 сек)**: Сервер начинает отправлять свои синхропакеты, а клиент измеряет скорость их поступления.
4.  **Согласование**: Стороны обмениваются финальным значением FPS и переходят в рабочий режим.
*Весь процесс занимает около 20 секунд.*

### Оптимизация и стабильность
*   **Динамическая вместимость**: Программа вычисляет максимально возможный объем данных для каждого кадра (`GetMaxPayloadSize`) в зависимости от размера блока и отступов. Это позволяет эффективно использовать всю площадь кадра.
*   **Buffer Pool**: Внедрена система пулов буферов для снижения нагрузки на GC при высоких скоростях.
*   **Автоматическая очистка**: Если в течение 500 мс не передается полезных данных, экран автоматически очищается.
*   **Адаптивный FPS**: Система постоянно мониторит подтвержденный FPS через Heartbeat-пакеты и может динамически изменять скорость передачи для обеспечения стабильности.
*   **Параллельный Dial**: На стороне сервера установка соединений (Dial) происходит асинхронно, что позволяет браузеру открывать десятки вкладок одновременно без задержек.

## Установка

1.  Установите [Go](https://go.dev/dl/).
2.  Соберите проект:
    ```bash
    go build -o video-go.exe .
    ```

## Использование

### 1. Подготовка видеосвязи
*   Запустите сервер или клиент. Приложение автоматически попытается зарегистрировать системную виртуальную камеру **"VideoGo Virtual Camera"**.
*   В приложении для видеозвонков (Discord, Zoom и др.) выберите эту камеру в качестве источника.
*   Если ваша система не поддерживает автоматическую регистрацию, используйте **MJPEG URL**, который будет выведен в консоль при старте.

### 2. Запуск сервера (выходной узел)
Сервер будет считывать запросы клиента с экрана и отправлять ответы через виртуальную камеру.
```bash
./video-go.exe -mode=server
```
При первом запуске (или если координаты не сохранены) откроется полупрозрачное окно. Перетащите его так, чтобы оно накрывало область, где отображается видео от клиента, и нажмите **ENTER**. Координаты будут сохранены в `config_server.json` и использованы при следующем запуске.

*   `-capture-x`, `-capture-y`: Можно указать координаты вручную.
*   `-margin`: Отступ от краев (в пикселях) при генерации и захвате видео. Помогает, если края видео обрезаются платформой связи. По умолчанию: 10.
*   `-ui`: Принудительно вызвать окно выбора при старте.
*   `-vcam-mjpeg`: Включить MJPEG сервер (по умолчанию: true).
*   `-vcam-native`: Включить регистрацию системной виртуальной камеры (по умолчанию: true).
*   `-vcam-name`: Название виртуальной камеры. По умолчанию: "VideoGo Server Camera" для сервера и "VideoGo Client Camera" для клиента.
*   `-block-size`: Размер блока данных в пикселях. Меньше размер — выше плотность данных, но требуется лучшее качество видео. По умолчанию: 4.

### Контрольные точки и Автотрекинг
В каждом генерируемом кадре в углах присутствуют контрольные точки (8x8 пикселя). Система использует их не только для ручного совмещения, но и для **автоматического поиска и слежения** за областью захвата:
*   **Цвета Клиента**: Красный, Зеленый, Синий, Белый.
*   **Цвета Сервера**: Бирюзовый, Пурпурный, Желтый, Оранжевый.

**Как это работает:**
*   При старте приложение сканирует весь экран в поисках маркеров удаленной стороны.
*   Как только маркеры найдены, область захвата автоматически центрируется на них.
*   Если окно с видео переместится, система обнаружит смещение маркеров и скорректирует координаты захвата "на лету".
*   Это позволяет свободно перемещать окна Discord/Zoom во время работы туннеля.

### Горячие клавиши (только Windows)
*   **Ctrl+Alt+S** (для сервера): Вызвать окно выбора области захвата во время работы.
*   **Ctrl+Alt+C** (для клиента): Вызвать окно выбора области захвата во время работы.
*   После выбора новые координаты будут применены "на лету" и сохранены в соответствующий конфиг.

### 3. Запуск клиента (входной узел)
Клиент создает SOCKS5 прокси на локальном порту.
```bash
./video-go.exe -mode=client -local=:1080
```
Аналогично серверу, выберите область экрана, где отображается видео от сервера, и нажмите **ENTER**. Координаты сохранятся в `config_client.json`.

### 4. Debug UI (Отладка)
Для удобства отладки и тестирования (особенно при запуске сервера и клиента на одной машине) можно использовать встроенный просмотрщик видео в обоих режимах:

**Режим сервера:**
```bash
./video-go.exe -mode=server -debug-ui
```

**Режим клиента:**
```bash
./video-go.exe -mode=client -debug-ui
```

*   **-debug-ui**: Открывает окно, в котором можно просматривать видеопоток от другого узла.
*   **-debug-url**: Можно сразу указать MJPEG URL для просмотра.
*   **-debug-x**, **-debug-y**: Позволяют задать начальное положение окна Debug UI.
*   **-vcam-port**: Позволяет задать фиксированный порт для встроенного MJPEG сервера.
*   В заголовке окна Debug UI отображается ваш локальный MJPEG URL, который нужно вставить в другое запущенное приложение (в поле ввода и нажать **Connect**) для "соединения" их между собой.
*   Вы можете навести окно выбора области захвата (`ui`) прямо на это окно Debug UI для проведения тестов без использования сторонних приложений (Zoom/Discord).

### Playground (Быстрый старт)
В папке `playground` находится скрипт `run_playground.ps1`, который автоматически собирает проект и запускает настроенную связку клиент-сервер на одной машине. Это позволяет сразу проверить работоспособность SOCKS5 прокси.

Запуск:
```powershell
powershell ./playground/run_playground.ps1
```
После запуска подождите около **20 секунд** для прохождения фазы взаимной калибровки (индикаторы прогресса будут видны в консоли). Затем проверьте прокси:
```bash
curl --socks5 localhost:1080 http://google.com
```

### 5. Настройка прокси
Настройте браузер или используйте curl для работы через SOCKS5:
```bash
curl --socks5 localhost:1080 http://google.com
```

## Виртуальная камера

В проекте реализована собственная система виртуальной камеры, не требующая установки сторонних драйверов:

*   **Media Foundation (Windows)**: Используется современный системный API `MFCreateVirtualCamera`. Камера регистрируется динамически при запуске приложения и удаляется при закрытии. Требуется Windows 10 версии 2004 или выше.
*   **MJPEG Server**: Встроенный HTTP-сервер транслирует видеопоток в реальном времени. Это позволяет подключать видео к OBS, VLC или другим плеерам по сетевому URL (будет выведен в консоль).

## Экспериментальные функции (v2.0)

В текущей версии внедрены следующие улучшения:
*   **Reed-Solomon (RS) кодирование**: Вместо простого дублирования блоков используется помехоустойчивое кодирование Рида-Соломона (32 байта коррекции на каждые 223 байта данных). Это значительно повышает пропускную способность при сохранении высокой надежности.
*   **16-цветовая палитра**: Кодек перешел с 8-цветовой палитры (3 бита) на 16-цветовую (4 бита на блок), что дало прирост скорости на ~33%.
*   **Адаптивный размер блока**: Система автоматически подстраивает размер блока данных (от 4 до 12 пикселей) в зависимости от качества связи. Текущий размер блока передается в метаданных каждого кадра.

### Технические подробности (v2.0)
*   **Разрешение**: 640x480.
*   **Цветовое пространство**: 16-цветовая оптимизированная палитра.
*   **Защита данных**: CRC32 + Reed-Solomon (NSYM=32).
*   **Пропускная способность**: 
    *   До 350 КБ/с на идеальных каналах.
    *   Автоматическое снижение скорости при росте ошибок.

## Тестирование

```bash
go test -v .
```
